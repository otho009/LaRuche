{"map":"{\"version\":3,\"sources\":[\"/var/www/html/s6/LaRuche/prototype_wissem/server/node_modules/punycode/punycode.js\"],\"names\":[\"maxInt\",\"regexPunycode\",\"regexNonASCII\",\"regexSeparators\",\"errors\",\"overflow\",\"not-basic\",\"invalid-input\",\"floor\",\"Math\",\"stringFromCharCode\",\"String\",\"fromCharCode\",\"error\",\"type\",\"RangeError\",\"mapDomain\",\"string\",\"fn\",\"parts\",\"split\",\"result\",\"length\",\"encoded\",\"array\",\"map\",\"replace\",\"join\",\"ucs2decode\",\"output\",\"counter\",\"value\",\"charCodeAt\",\"extra\",\"push\",\"digitToBasic\",\"digit\",\"flag\",\"adapt\",\"delta\",\"numPoints\",\"firstTime\",\"k\",\"baseMinusTMin\",\"base\",\"decode\",\"input\",\"inputLength\",\"i\",\"n\",\"bias\",\"basic\",\"lastIndexOf\",\"j\",\"index\",\"oldi\",\"w\",\"codePoint\",\"t\",\"baseMinusT\",\"out\",\"splice\",\"fromCodePoint\",\"encode\",\"currentValue\",\"basicLength\",\"handledCPCount\",\"m\",\"handledCPCountPlusOne\",\"q\",\"qMinusT\",\"punycode\",\"version\",\"ucs2\",\"toASCII\",\"test\",\"toUnicode\",\"slice\",\"toLowerCase\",\"module\",\"exports\"],\"mappings\":\"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\",\"sourcesContent\":[\"'use strict';\\n\\n/** Highest positive signed 32-bit float value */\\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\\n\\n/** Bootstring parameters */\\nconst base = 36;\\nconst tMin = 1;\\nconst tMax = 26;\\nconst skew = 38;\\nconst damp = 700;\\nconst initialBias = 72;\\nconst initialN = 128; // 0x80\\nconst delimiter = '-'; // '\\\\x2D'\\n\\n/** Regular expressions */\\nconst regexPunycode = /^xn--/;\\nconst regexNonASCII = /[^\\\\0-\\\\x7E]/; // non-ASCII chars\\nconst regexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g; // RFC 3490 separators\\n\\n/** Error messages */\\nconst errors = {\\n\\t'overflow': 'Overflow: input needs wider integers to process',\\n\\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\n\\t'invalid-input': 'Invalid input'\\n};\\n\\n/** Convenience shortcuts */\\nconst baseMinusTMin = base - tMin;\\nconst floor = Math.floor;\\nconst stringFromCharCode = String.fromCharCode;\\n\\n/*--------------------------------------------------------------------------*/\\n\\n/**\\n * A generic error utility function.\\n * @private\\n * @param {String} type The error type.\\n * @returns {Error} Throws a `RangeError` with the applicable error message.\\n */\\nfunction error(type) {\\n\\tthrow new RangeError(errors[type]);\\n}\\n\\n/**\\n * A generic `Array#map` utility function.\\n * @private\\n * @param {Array} array The array to iterate over.\\n * @param {Function} callback The function that gets called for every array\\n * item.\\n * @returns {Array} A new array of values returned by the callback function.\\n */\\nfunction map(array, fn) {\\n\\tconst result = [];\\n\\tlet length = array.length;\\n\\twhile (length--) {\\n\\t\\tresult[length] = fn(array[length]);\\n\\t}\\n\\treturn result;\\n}\\n\\n/**\\n * A simple `Array#map`-like wrapper to work with domain name strings or email\\n * addresses.\\n * @private\\n * @param {String} domain The domain name or email address.\\n * @param {Function} callback The function that gets called for every\\n * character.\\n * @returns {Array} A new string of characters returned by the callback\\n * function.\\n */\\nfunction mapDomain(string, fn) {\\n\\tconst parts = string.split('@');\\n\\tlet result = '';\\n\\tif (parts.length > 1) {\\n\\t\\t// In email addresses, only the domain name should be punycoded. Leave\\n\\t\\t// the local part (i.e. everything up to `@`) intact.\\n\\t\\tresult = parts[0] + '@';\\n\\t\\tstring = parts[1];\\n\\t}\\n\\t// Avoid `split(regex)` for IE8 compatibility. See #17.\\n\\tstring = string.replace(regexSeparators, '\\\\x2E');\\n\\tconst labels = string.split('.');\\n\\tconst encoded = map(labels, fn).join('.');\\n\\treturn result + encoded;\\n}\\n\\n/**\\n * Creates an array containing the numeric code points of each Unicode\\n * character in the string. While JavaScript uses UCS-2 internally,\\n * this function will convert a pair of surrogate halves (each of which\\n * UCS-2 exposes as separate characters) into a single code point,\\n * matching UTF-16.\\n * @see `punycode.ucs2.encode`\\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n * @memberOf punycode.ucs2\\n * @name decode\\n * @param {String} string The Unicode input string (UCS-2).\\n * @returns {Array} The new array of code points.\\n */\\nfunction ucs2decode(string) {\\n\\tconst output = [];\\n\\tlet counter = 0;\\n\\tconst length = string.length;\\n\\twhile (counter < length) {\\n\\t\\tconst value = string.charCodeAt(counter++);\\n\\t\\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n\\t\\t\\t// It's a high surrogate, and there is a next character.\\n\\t\\t\\tconst extra = string.charCodeAt(counter++);\\n\\t\\t\\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\\n\\t\\t\\t\\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// It's an unmatched surrogate; only append this code unit, in case the\\n\\t\\t\\t\\t// next code unit is the high surrogate of a surrogate pair.\\n\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t\\tcounter--;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput.push(value);\\n\\t\\t}\\n\\t}\\n\\treturn output;\\n}\\n\\n/**\\n * Creates a string based on an array of numeric code points.\\n * @see `punycode.ucs2.decode`\\n * @memberOf punycode.ucs2\\n * @name encode\\n * @param {Array} codePoints The array of numeric code points.\\n * @returns {String} The new Unicode string (UCS-2).\\n */\\nconst ucs2encode = array => String.fromCodePoint(...array);\\n\\n/**\\n * Converts a basic code point into a digit/integer.\\n * @see `digitToBasic()`\\n * @private\\n * @param {Number} codePoint The basic numeric code point value.\\n * @returns {Number} The numeric value of a basic code point (for use in\\n * representing integers) in the range `0` to `base - 1`, or `base` if\\n * the code point does not represent a value.\\n */\\nconst basicToDigit = function(codePoint) {\\n\\tif (codePoint - 0x30 < 0x0A) {\\n\\t\\treturn codePoint - 0x16;\\n\\t}\\n\\tif (codePoint - 0x41 < 0x1A) {\\n\\t\\treturn codePoint - 0x41;\\n\\t}\\n\\tif (codePoint - 0x61 < 0x1A) {\\n\\t\\treturn codePoint - 0x61;\\n\\t}\\n\\treturn base;\\n};\\n\\n/**\\n * Converts a digit/integer into a basic code point.\\n * @see `basicToDigit()`\\n * @private\\n * @param {Number} digit The numeric value of a basic code point.\\n * @returns {Number} The basic code point whose value (when used for\\n * representing integers) is `digit`, which needs to be in the range\\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\n * used; else, the lowercase form is used. The behavior is undefined\\n * if `flag` is non-zero and `digit` has no uppercase form.\\n */\\nconst digitToBasic = function(digit, flag) {\\n\\t//  0..25 map to ASCII a..z or A..Z\\n\\t// 26..35 map to ASCII 0..9\\n\\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\n};\\n\\n/**\\n * Bias adaptation function as per section 3.4 of RFC 3492.\\n * https://tools.ietf.org/html/rfc3492#section-3.4\\n * @private\\n */\\nconst adapt = function(delta, numPoints, firstTime) {\\n\\tlet k = 0;\\n\\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\\n\\tdelta += floor(delta / numPoints);\\n\\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\\n\\t\\tdelta = floor(delta / baseMinusTMin);\\n\\t}\\n\\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n};\\n\\n/**\\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\n * symbols.\\n * @memberOf punycode\\n * @param {String} input The Punycode string of ASCII-only symbols.\\n * @returns {String} The resulting string of Unicode symbols.\\n */\\nconst decode = function(input) {\\n\\t// Don't use UCS-2.\\n\\tconst output = [];\\n\\tconst inputLength = input.length;\\n\\tlet i = 0;\\n\\tlet n = initialN;\\n\\tlet bias = initialBias;\\n\\n\\t// Handle the basic code points: let `basic` be the number of input code\\n\\t// points before the last delimiter, or `0` if there is none, then copy\\n\\t// the first basic code points to the output.\\n\\n\\tlet basic = input.lastIndexOf(delimiter);\\n\\tif (basic < 0) {\\n\\t\\tbasic = 0;\\n\\t}\\n\\n\\tfor (let j = 0; j < basic; ++j) {\\n\\t\\t// if it's not a basic code point\\n\\t\\tif (input.charCodeAt(j) >= 0x80) {\\n\\t\\t\\terror('not-basic');\\n\\t\\t}\\n\\t\\toutput.push(input.charCodeAt(j));\\n\\t}\\n\\n\\t// Main decoding loop: start just after the last delimiter if any basic code\\n\\t// points were copied; start at the beginning otherwise.\\n\\n\\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\\n\\n\\t\\t// `index` is the index of the next character to be consumed.\\n\\t\\t// Decode a generalized variable-length integer into `delta`,\\n\\t\\t// which gets added to `i`. The overflow checking is easier\\n\\t\\t// if we increase `i` as we go, then subtract off its starting\\n\\t\\t// value at the end to obtain `delta`.\\n\\t\\tlet oldi = i;\\n\\t\\tfor (let w = 1, k = base; /* no condition */; k += base) {\\n\\n\\t\\t\\tif (index >= inputLength) {\\n\\t\\t\\t\\terror('invalid-input');\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst digit = basicToDigit(input.charCodeAt(index++));\\n\\n\\t\\t\\tif (digit >= base || digit > floor((maxInt - i) / w)) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\ti += digit * w;\\n\\t\\t\\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\n\\t\\t\\tif (digit < t) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst baseMinusT = base - t;\\n\\t\\t\\tif (w > floor(maxInt / baseMinusT)) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tw *= baseMinusT;\\n\\n\\t\\t}\\n\\n\\t\\tconst out = output.length + 1;\\n\\t\\tbias = adapt(i - oldi, out, oldi == 0);\\n\\n\\t\\t// `i` was supposed to wrap around from `out` to `0`,\\n\\t\\t// incrementing `n` each time, so we'll fix that now:\\n\\t\\tif (floor(i / out) > maxInt - n) {\\n\\t\\t\\terror('overflow');\\n\\t\\t}\\n\\n\\t\\tn += floor(i / out);\\n\\t\\ti %= out;\\n\\n\\t\\t// Insert `n` at position `i` of the output.\\n\\t\\toutput.splice(i++, 0, n);\\n\\n\\t}\\n\\n\\treturn String.fromCodePoint(...output);\\n};\\n\\n/**\\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n * Punycode string of ASCII-only symbols.\\n * @memberOf punycode\\n * @param {String} input The string of Unicode symbols.\\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\\n */\\nconst encode = function(input) {\\n\\tconst output = [];\\n\\n\\t// Convert the input in UCS-2 to an array of Unicode code points.\\n\\tinput = ucs2decode(input);\\n\\n\\t// Cache the length.\\n\\tlet inputLength = input.length;\\n\\n\\t// Initialize the state.\\n\\tlet n = initialN;\\n\\tlet delta = 0;\\n\\tlet bias = initialBias;\\n\\n\\t// Handle the basic code points.\\n\\tfor (const currentValue of input) {\\n\\t\\tif (currentValue < 0x80) {\\n\\t\\t\\toutput.push(stringFromCharCode(currentValue));\\n\\t\\t}\\n\\t}\\n\\n\\tlet basicLength = output.length;\\n\\tlet handledCPCount = basicLength;\\n\\n\\t// `handledCPCount` is the number of code points that have been handled;\\n\\t// `basicLength` is the number of basic code points.\\n\\n\\t// Finish the basic string with a delimiter unless it's empty.\\n\\tif (basicLength) {\\n\\t\\toutput.push(delimiter);\\n\\t}\\n\\n\\t// Main encoding loop:\\n\\twhile (handledCPCount < inputLength) {\\n\\n\\t\\t// All non-basic code points < n have been handled already. Find the next\\n\\t\\t// larger one:\\n\\t\\tlet m = maxInt;\\n\\t\\tfor (const currentValue of input) {\\n\\t\\t\\tif (currentValue >= n && currentValue < m) {\\n\\t\\t\\t\\tm = currentValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\n\\t\\t// but guard against overflow.\\n\\t\\tconst handledCPCountPlusOne = handledCPCount + 1;\\n\\t\\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n\\t\\t\\terror('overflow');\\n\\t\\t}\\n\\n\\t\\tdelta += (m - n) * handledCPCountPlusOne;\\n\\t\\tn = m;\\n\\n\\t\\tfor (const currentValue of input) {\\n\\t\\t\\tif (currentValue < n && ++delta > maxInt) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\t\\t\\tif (currentValue == n) {\\n\\t\\t\\t\\t// Represent delta as a generalized variable-length integer.\\n\\t\\t\\t\\tlet q = delta;\\n\\t\\t\\t\\tfor (let k = base; /* no condition */; k += base) {\\n\\t\\t\\t\\t\\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\t\\t\\t\\t\\tif (q < t) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tconst qMinusT = q - t;\\n\\t\\t\\t\\t\\tconst baseMinusT = base - t;\\n\\t\\t\\t\\t\\toutput.push(\\n\\t\\t\\t\\t\\t\\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\tq = floor(qMinusT / baseMinusT);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\\n\\t\\t\\t\\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n\\t\\t\\t\\tdelta = 0;\\n\\t\\t\\t\\t++handledCPCount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t++delta;\\n\\t\\t++n;\\n\\n\\t}\\n\\treturn output.join('');\\n};\\n\\n/**\\n * Converts a Punycode string representing a domain name or an email address\\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\n * it doesn't matter if you call it on a string that has already been\\n * converted to Unicode.\\n * @memberOf punycode\\n * @param {String} input The Punycoded domain name or email address to\\n * convert to Unicode.\\n * @returns {String} The Unicode representation of the given Punycode\\n * string.\\n */\\nconst toUnicode = function(input) {\\n\\treturn mapDomain(input, function(string) {\\n\\t\\treturn regexPunycode.test(string)\\n\\t\\t\\t? decode(string.slice(4).toLowerCase())\\n\\t\\t\\t: string;\\n\\t});\\n};\\n\\n/**\\n * Converts a Unicode string representing a domain name or an email address to\\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\\n * i.e. it doesn't matter if you call it with a domain that's already in\\n * ASCII.\\n * @memberOf punycode\\n * @param {String} input The domain name or email address to convert, as a\\n * Unicode string.\\n * @returns {String} The Punycode representation of the given domain name or\\n * email address.\\n */\\nconst toASCII = function(input) {\\n\\treturn mapDomain(input, function(string) {\\n\\t\\treturn regexNonASCII.test(string)\\n\\t\\t\\t? 'xn--' + encode(string)\\n\\t\\t\\t: string;\\n\\t});\\n};\\n\\n/*--------------------------------------------------------------------------*/\\n\\n/** Define the public API */\\nconst punycode = {\\n\\t/**\\n\\t * A string representing the current Punycode.js version number.\\n\\t * @memberOf punycode\\n\\t * @type String\\n\\t */\\n\\t'version': '2.1.0',\\n\\t/**\\n\\t * An object of methods to convert from JavaScript's internal character\\n\\t * representation (UCS-2) to Unicode code points, and back.\\n\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n\\t * @memberOf punycode\\n\\t * @type Object\\n\\t */\\n\\t'ucs2': {\\n\\t\\t'decode': ucs2decode,\\n\\t\\t'encode': ucs2encode\\n\\t},\\n\\t'decode': decode,\\n\\t'encode': encode,\\n\\t'toASCII': toASCII,\\n\\t'toUnicode': toUnicode\\n};\\n\\nmodule.exports = punycode;\\n\"]}","code":"webpackHotUpdate(0,{60:!1,61:function(t,o,n){\"use strict\";const e=2147483647,r=/^xn--/,c=/[^\\0-\\x7E]/,s=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,i={overflow:\"Overflow: input needs wider integers to process\",\"not-basic\":\"Illegal input >= 0x80 (not a basic code point)\",\"invalid-input\":\"Invalid input\"},f=Math.floor,l=String.fromCharCode;function u(t){throw new RangeError(i[t])}function a(t,o){const n=t.split(\"@\");let e=\"\";n.length>1&&(e=n[0]+\"@\",t=n[1]);const r=function(t,o){const n=[];let e=t.length;for(;e--;)n[e]=o(t[e]);return n}((t=t.replace(s,\".\")).split(\".\"),o).join(\".\");return e+r}function d(t){const o=[];let n=0;const e=t.length;for(;n<e;){const r=t.charCodeAt(n++);if(r>=55296&&r<=56319&&n<e){const e=t.charCodeAt(n++);56320==(64512&e)?o.push(((1023&r)<<10)+(1023&e)+65536):(o.push(r),n--)}else o.push(r)}return o}const h=function(t,o){return t+22+75*(t<26)-((0!=o)<<5)},p=function(t,o,n){let e=0;for(t=n?f(t/700):t>>1,t+=f(t/o);t>455;e+=36)t=f(t/35);return f(e+36*t/(t+38))},g=function(t){const o=[],n=t.length;let r=0,c=128,s=72,i=t.lastIndexOf(\"-\");i<0&&(i=0);for(let n=0;n<i;++n)t.charCodeAt(n)>=128&&u(\"not-basic\"),o.push(t.charCodeAt(n));for(let a=i>0?i+1:0;a<n;){let i=r;for(let o=1,c=36;;c+=36){a>=n&&u(\"invalid-input\");const i=(l=t.charCodeAt(a++))-48<10?l-22:l-65<26?l-65:l-97<26?l-97:36;(i>=36||i>f((e-r)/o))&&u(\"overflow\"),r+=i*o;const d=c<=s?1:c>=s+26?26:c-s;if(i<d)break;const h=36-d;o>f(e/h)&&u(\"overflow\"),o*=h}const d=o.length+1;s=p(r-i,d,0==i),f(r/d)>e-c&&u(\"overflow\"),c+=f(r/d),r%=d,o.splice(r++,0,c)}var l;return String.fromCodePoint(...o)},v=function(t){const o=[];let n=(t=d(t)).length,r=128,c=0,s=72;for(const n of t)n<128&&o.push(l(n));let i=o.length,a=i;for(i&&o.push(\"-\");a<n;){let n=e;for(const o of t)o>=r&&o<n&&(n=o);const d=a+1;n-r>f((e-c)/d)&&u(\"overflow\"),c+=(n-r)*d,r=n;for(const n of t)if(n<r&&++c>e&&u(\"overflow\"),n==r){let t=c;for(let n=36;;n+=36){const e=n<=s?1:n>=s+26?26:n-s;if(t<e)break;const r=t-e,c=36-e;o.push(l(h(e+r%c,0))),t=f(r/c)}o.push(l(h(t,0))),s=p(c,d,a==i),c=0,++a}++c,++r}return o.join(\"\")},w={version:\"2.1.0\",ucs2:{decode:d,encode:t=>String.fromCodePoint(...t)},decode:g,encode:v,toASCII:function(t){return a(t,function(t){return c.test(t)?\"xn--\"+v(t):t})},toUnicode:function(t){return a(t,function(t){return r.test(t)?g(t.slice(4).toLowerCase()):t})}};t.exports=w}});","extractedComments":[]}